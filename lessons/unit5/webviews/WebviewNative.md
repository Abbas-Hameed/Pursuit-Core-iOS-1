# WKWebView and Native Interaction

## References

### Learn to be a web developer in 6 links

> AC 3.1 eat your hearts out

1. http://www.w3schools.com/html/html_intro.asp
1. http://www.w3schools.com/html/html_styles.asp
1. http://www.w3schools.com/html/html_css.asp
1. http://www.w3schools.com/html/html_classes.asp
1. http://www.w3schools.com/css/default.asp
1. http://www.w3schools.com/js/js_intro.asp

### WKWebView

1. https://developer.apple.com/reference/webkit/wkscriptmessagehandler
1. https://developer.apple.com/reference/webkit/wknavigationdelegate, specifically [```webView(_:decidePolicyFor:decisionHandler:)```](https://developer.apple.com/reference/webkit/wknavigationdelegate/1455641-webview)
1. [WKWebKit - NSHipster](http://nshipster.com/wkwebkit/), specifically the JavaScript ↔︎ Swift Communication bit.

## Lesson

### Why communicate? What's the point?

What are the motivations to communicate between your app and a Webview it contains? Here are a few:

* alter content (you probably don't control the URL)
* block links (you probably don't control the URL)
* hybrid apps (you probably have some control over the URL)

### Some thoughts about what's going on

Remember that there's entirely independent application running inside the WebView. It's loaded
some HTML and Javascript and that gets running. There is a wide range of complexity to web pages.
Consider a relatively static page like a Wikipedia page as compared to a Gmail inbox. The former
is assempled mostly on the server and just dumped into the browser as HTML to display. The latter
is a complex application heavily dependent upon Javascript.

Web programming is more layered than iOS, in that code is generated by otehr code. A common sequence
of stages might be:

```
(PHP/Java/Python) -> HTML -> CSS -> JS
```

A server side language generates a base HTML page, it loads in CSS which is a set of rules about
styling and then Javascript runs on top of that. The Javascript can alter things at the time of
loading or afterward, possibly making new network requests for an already-loaded page (AJAX).

DOM - Document Object Model. HTML is a tree of nodes.
Swift making JS that's manipulating HTML or the DOM, really.
DOM is a good tree response in an interview question. Tree representation.

**Mobile**

The form factor of a mobile device (small and hi res) has resulting in something called
responsive design. This means the styles on the page respond to this size and alter the content,
in the simplest/simplistic terms, bumping up font sizes and making things more vertical.

Since we're already way too deep into this I just grabbed the first reasonable-looking mobile
styles from http://getskeleton.com/. 

**Glue**

So what *is* going on? What's our role? If you find yourself writing this kind of code 
you're probably on a team that's got an able web team. As iOS developer you'd be focusing
on writing this kind of glue code, not the particulars of the display within the Webview.

### Executing Javascript from Swift

There are two ways to do this. One is by "injection", which happens exactly once on page load,
either at the beginning or the end, and the other is to run arbitrary Javascript
in the WebView on demand. This can be triggered any number of times.

#### Injection

```swift
let webConfiguration = WKWebViewConfiguration()
let userContentController = WKUserContentController()

let source = "document.body.style.background = \"#40c\";" // purplish
let userScript = WKUserScript(source: source, injectionTime: .atDocumentEnd, forMainFrameOnly: true)

userContentController.addUserScript(userScript)
webConfiguration.userContentController = userContentController
webView = WKWebView(frame: .zero, configuration: webConfiguration)
```

#### On demand

```swift
js += "document.getElementById('box1').innerHTML = 'red'"
webView.evaluateJavaScript(js) { (stuff, error) in
    print(stuff ?? "whoops")
}
```

### Executing Swift from Javascript

First add the handler:

```swift
let webConfiguration = WKWebViewConfiguration()
let userContentController = WKUserContentController()

// self conforms to protocol WKScriptMessageHandler
userContentController.add(self, name: "doEeet")

webConfiguration.userContentController = userContentController
webView = WKWebView(frame: .zero, configuration: webConfiguration)
```

Then catch messages:

```swift
func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
    print("Received message named: \(message.name)")
    print(message.body)
    
    if let msg = message.body as? [String:Any] {
        print(msg["msg"] ?? "whoops")
    }
}
```

### Debugging

You can configure your testing environment so that you can debug the WKWebView(s) in your app
interactively in desktop Safari. Definitely some magic going on there. Follow this guide:

https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html

I _believe_ this instruction for "WebKit-based apps"

```
defaults write com.bundle.identifier WebKitDeveloperExtras -bool true
```

is for Mac apps, so you can try to test w/o it first. (I'm hazy on it because I *did* run this on the command line
first, and while I subsequently ran it again with ```-bool false```, who knows?). If, after you follow the instructions
it still doesn't work you can try it. If you do, be sure to use the bundle from your app. The bundle is in Info.plist
and is featured in the General settings when you highlight your target. It usually looks something like 'nyc.c4q.WebviewAndJS'. 

**NB: I found that after following these instructions, I had to restart Safari and "Reset Content and Settings" in 
the Simulator.**


## Exercises:
1. Add a Text Field and send its content to a div in the WebView.
1. Write the "the cloud" to "my butt" (or similar) filter 
